
AVRASM ver. 2.1.57  C:\Users\Owner\Documents\Atmel Studio\6.2\tu58v3\tu58v3\tu58v3.asm Fri Aug 16 10:11:14 2019

[builtin](2): Including file 'C:\Program Files\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m32Adef.inc'
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32A.xml ***********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m32Adef.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega32A
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega32A
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M32ADEF_INC_
                 #define _M32ADEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega32A
                 #pragma AVRPART ADMIN PART_NAME ATmega32A
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x02
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	OCR0	= 0x3c
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	OCDR	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTA	= 0x1b
                 .equ	DDRA	= 0x1a
                 .equ	PINA	= 0x19
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDTOE	= 4	; RW
                 .equ	WDDE	= WDTOE	; For compatibility
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF2	= 5	; External Interrupt Flag 2
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - General Interrupt Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	ISC2	= 6	; Interrupt Sense Control 2
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TCCR0 - Timer/Counter Control Register
                 .equ	CS00	= 0	; Clock Select 1
                 .equ	CS01	= 1	; Clock Select 1
                 .equ	CS02	= 2	; Clock Select 2
                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                 .equ	CTC0	= WGM01	; For compatibility
                 .equ	COM00	= 4	; Compare match Output Mode 0
                 .equ	COM01	= 5	; Compare Match Output Mode 1
                 .equ	WGM00	= 6	; Waveform Generation Mode
                 .equ	PWM0	= WGM00	; For compatibility
                 .equ	FOC0	= 7	; Force Output Compare
                 
                 ; TCNT0 - Timer/Counter Register
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0 - Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0	= 1	; Output Compare Flag 0
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Clear Timer/Counter2 on Compare Match
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Pulse Width Modulator Enable
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; When this bit is written to one,the Timer/Counter2 prescaler will be reset.The bit will be cleared by hardware after the operation is performed.Writing a zero to this bit will have no effect.This bit will always be read as zero if Timer/C                 ounter2 is clocked by the internal CPU clock.If this bit is written when Timer/Counter2 is operating in asynchronous mode,the bit will remain one until the prescaler has been reset.
                 .equ	ADFR	= ADATE	; For compatibility
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; SFIOR - Special Function IO Register
                 .equ	ADTS0	= 5	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 6	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 7	; ADC Auto Trigger Source 2
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1&0
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PUD	= 2	; Pull-up Disable
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                 .equ	ASRE	= RWWSRE	; For compatibility
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	ASB	= RWWSB	; For compatibility
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler bits
                 .equ	TWPS1	= 1	; TWI Prescaler bits
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x085f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	OC2addr	= 0x0008	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x000a	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x000c	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x000e	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0010	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0012	; Timer/Counter1 Overflow
                 .equ	OC0addr	= 0x0014	; Timer/Counter0 Compare Match
                 .equ	OVF0addr	= 0x0016	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0018	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x001a	; USART, Rx Complete
                 .equ	UDREaddr	= 0x001c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x001e	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x0020	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x0022	; EEPROM Ready
                 .equ	ACIaddr	= 0x0024	; Analog Comparator
                 .equ	TWIaddr	= 0x0026	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0028	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 42	; size in words
                 
                 #endif  /* _M32ADEF_INC_ */
                 
                 
                 ; tu58v3.asm
                 ;
                 ; DEC TU-58 tape system emulator
                 ;  Created: 06/12/2019
                 ;   Author: Joseph C. Lang
                 ;   Copyright (C) 2019
                 ;   Released to the public domain
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ; Storage is on a single CF card
                 ; This code is for the version 3 board
                 ; Version 3 changed to the ATmega32A processor
                 ; it has a parallel interface to the CF card
                 ; Eliminating the SPI interface used in V1 and V2
                 ; Version 3 also has config jumpers to select baud rate
                 ;
                 ; AVR Fuses: L=0xE0 h=0xB9
                 ;
                         .DSEG
                 ;
                 ;SRAM locations:
                 ;
                 	.ORG $100	;skip past register space
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;CF card read/write buffer (512 bytes)
                 ;the buffer is loaded/unloaded 128 bytes at a time (RSP protocol)
                 ;the var BUFSEG selects the 128 byte area currently used
                 ;
000100           BUFFER:	.BYTE 512	;cf card read/write buffer
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;command/response packet storage
                 ;some addresses are duplicated
                 ;since command and response use
                 ;some fields differently
                 ;the values are in the same order as
                 ;defined in the RSP packet
                 ;
000300           PK_FLAG:	.BYTE  1      ;flag
000301           PK_CMDCT:	.BYTE  1      ;count
000302           PK_OPCD:	.BYTE  1      ;op code
                 ;
                 PK_MOD:			      ;modifyer
000303           PK_SUCC:	.BYTE  1      ;success code
                 ;
000304           PK_UNIT:	.BYTE  1      ;unit
000305           PK_SWIT:	.BYTE  1      ;switches
000306           PK_SEQL:	.BYTE  1      ;sequence low (unused)
000307           PK_SEQH:	.BYTE  1      ;sequence hi (unused)
000308           PK_CNTL:	.BYTE  1      ;byte count low
000309           PK_CNTH:	.BYTE  1      ;byte count hi
                 ;
                 PK_BLKL:		      ;block number low
00030a           PK_SUMSL:	.BYTE  1      ;summary status low
                 ;
                 PK_BLKH:		      ;block number high
00030b           PK_SUMSH:	.BYTE  1      ;summary status hi
                 ;
00030c           PK_CHKL:	.BYTE  1      ;packet check low
00030d           PK_CHKH:	.BYTE  1      ;packet check high
                 ;
                 ;data packet storage
00030e           BF_FLAG:	.BYTE  1      ;response type
00030f           BF_DATCT:	.BYTE  1      ;response byte count
000310           BF_DATA:	.BYTE  128    ;response data
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;SRAM variables
000390           CUR_BL:		.BYTE  1      ;current block low
000391           CUR_BH:		.BYTE  1      ;current block high
000392           BYT_DONL:	.BYTE  1      ;transfered count
000393           BYT_DONH:	.BYTE  1      ;transfered count
000394           SUCCES:		.BYTE  2      ;success code
000396           SUMST:		.BYTE  1      ;summary status
000397           FL_BOOT:	.BYTE  1      ;boot flag
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;register variables
                 .def BUFSEG	= r1	;current buffer segment
                 .def CHKLO	= r8	;calculated checksum low
                 .def CHKHI	= r9	;calculated checksum hi
                 .def FL_GO	= r10	;flag GO
                 .def FL_XOFF	= r11	;xoff flag
                 .def FL_TOG	= r12	;checksum byte toggle
                 ;r16 accumulator
                 ;r17 temp value
                 .def STATEL	= r19	;current state low
                 .def STATEH	= r20	;current state high
                 .def COUNT	= r21	;counter
                 .def BYTCNTL	= r22   ;byte counter low (to go)
                 .def BYTCNTH	= r23   ;byte counter hi
                 ; r26,r27 rx data pointer
                 ; r28,r29 sram pointer
                 ; r30,r31 buffer pointer
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;packet flag bytes
                 .equ DATACH	= 1	;paket flag=data
                 .equ CMDCH	= 2	;packet flag=command
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;character constants
                 .equ INITCH	= 4	;init character
                 .equ BOOTCH	= 8	;boot character
                 .equ CONTIN	= $10	;xon continue character
                 .equ XOFFCH	= $13	;xoff stop character
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;port A:
                 ; bidirectional data bus connection to
                 ; CF card
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;port B pins:
                 ;outputs to control CF card
                 ;0 A0
                 ;1 A1
                 ;2 A2
                 ;3 rd-
                 ;4 wr-
                 ;5 unused
                 ;6 cs-
                 ;7 always 1 (CS3XX- on CF card not used)
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;port D pins: (inputs)
                 ;
                 ;0 USART RX
                 ;1 USART TX
                 ;interface to CF card (port D input): 
                 ;2 irq
                 ;3 drq
                 ;4 cfg 0
                 ;5 cfg 1
                 ;6 cfg 2
                 ;7 unused
                 ;
                 ; config jumpers
                 ; U unused
                 ; I in
                 ; O out
                 ;
                 ;	0 1 2   BAUD RATE
                 ;	U O O	9600
                 ;	U I O	19200
                 ;	U O I	38400
                 ;	U I I	115200
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;port C: (outputs)
                 ;
                 ;0 cf ack- (unused always hi)
                 ;1 unused
                 ;2-5 JTAG
                 ;6 unused
                 ;7 cf rst-
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;bit patterns for CF card control on port B:
                 ;  wr- and rd- set high (inactive) for later strobe
                 ;  sel- low (active)
                 ;  sbi cbi used to assert and negate read- and write-
                 ;
                 ;   7 6  5  4   3   2  1  0
                 ;   1 CS 1  wr  rd  A2 A1 A0 
                 ;
                 .equ CF_data	= $B8	;cf card data register
                 .equ CF_feat	= $B9	;cf card feature register
                 .equ CF_err		= $B9	;cf card error register
                 .equ CF_count	= $BA	;cf sector count
                 .equ CF_lba0	= $BB	;cf lbn bits 0-7
                 .equ CF_lba1	= $BC	;cf lbn bits 8-15
                 .equ CF_lba2	= $BD	;cf lbn bits 16-24
                 .equ CF_lba3	= $BE	;cf lbn/drive 
                 .equ CF_cmd		= $BF	;cf command register
                 .equ CF_stat	= $BF	;cf status register
                 .equ CF_nsel	= $40	;cf card select bit
                 ;
                 ;individual port B bits:
                 ;for use with cbi sbi instructions
                 .equ CF_wr		= 4	;write- bit
                 .equ CF_rd		= 3	;read- bit
                 .equ CF_csel	= 6	;cs0- bit
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;CF card status register bits
                 .equ CF_busy	= 7	;CF busy bit
                 .equ CF_drq		= 3	;CF data request
                 .equ CF_errb	= 0	;error bit
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;CF card commands/bits
                 .equ CF_8bit	= 1	;set 8bit feature
                 .equ CF_drv0	= $e0	;drive 0+lba mode
                 .equ CF_drv1	= $f0	;drive 1+lba mode
                 .equ CF_dread	= $20	;read command
                 .equ CF_dwrite	= $30	;write command
                 .equ CF_sfeat	= $ef	;set features command
                 ;
                 ;
                         .CSEG
                         .ORG 0
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;power on reset
                 ;reset/interrupt vectors
                 ;most are not used
000000 940c 002d 	jmp	tugo	;1 reset
000002 940c 002a 	jmp	dummy	;2 int0
000004 940c 002a 	jmp	dummy	;3 int1
000006 940c 002a 	jmp	dummy	;4 int2
000008 940c 002a 	jmp	dummy	;5 t2cmp
00000a 940c 002a 	jmp	dummy	;6 t2ovf
00000c 940c 002a 	jmp	dummy	;7 t1cap
00000e 940c 002a 	jmp	dummy	;8 t1cmpa
000010 940c 002a 	jmp	dummy	;9 t1cmpb
000012 940c 002a 	jmp	dummy	;10 t1ovf
000014 940c 002a 	jmp	dummy	;11 t0cmp
000016 940c 002a 	jmp	dummy	;12 t0ovf
000018 940c 002a 	jmp	dummy	;13 spi
00001a 940c 003d 	jmp	rx_in	;14 rxc
00001c 940c 002a 	jmp	dummy	;15 udre
00001e 940c 002a 	jmp	dummy	;16 txc
000020 940c 002a 	jmp	dummy	;17 adc
000022 940c 002a 	jmp	dummy	;18 eerdy
000024 940c 002a 	jmp	dummy	;19 anacmp
000026 940c 002a 	jmp	dummy	;20 twi
000028 940c 002a 	jmp	dummy	;21 spmrdy
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;fatal IRQ error
                 ;unexpected IRQ lands here
                 ;
00002a 94f8      dummy:	cli		;turn off IRQ
00002b 940c 002b here:	jmp	here	;fatal error
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;Cold start
                 ;
                 tugo:
00002d 94f8      	cli
00002e e50f      	ldi r16,low(RAMEND)	;set stack
00002f bf0d      	out SPL,r16
000030 e008      	ldi r16,high(RAMEND)
000031 bf0e      	out SPH,r16
                 ;
                 ;set protocol state to idle
000032 e730      	ldi STATEL,low(st_idle)
000033 e040      	ldi STATEH,high(st_idle)
                 ;
                 ;initialize system
000034 940e 0117 	call hard_init		;init hardware
000036 e000      	ldi r16,0x00
000037 9300 0305 	sts pk_swit,r16		;init switch
000039 940e 010c 	call soft_init		;init software
00003b 9478      	sei			;allow irq
                 ;
                 	;send init characters
00003c c161      	rjmp send_init		;spew init characters
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;USART character in interrupt
                 ;
                 rx_in:
00003d 930f      	push r16	;save register
00003e b70f      	in r16,SREG	;get sreg
00003f 930f      	push r16	;save SREG
                 ;
                 ;if framing error goto init_loop
                 ;else fall through to protocol handler
                 ;
000040 b10b      	in r16,UCSRA	;get status
000041 fd04      	sbrc r16,FE		;skip next if not framing error
000042 c004      	rjmp rx_in01	;jump to break handler
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;get RX chararacter
                 ;goto protocol handler
                 ;
000043 b10c      	in r16,UDR	;get serial data
                 ;
                 ;jump to current state handler
000044 933f      	push STATEL	;push current state
000045 934f      	push STATEH	;on the stack
000046 9508      	ret		;return to it
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; got framing error so restart protocol
                 ;
                 rx_in01:
000047 b10c      	in r16,UDR	;get serial data
000048 e055      	ldi COUNT,5	;retry count
000049 940c 00bb 	jmp init_loop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;common handler return
                 ;
                 com_rtn:
00004b 910f      	pop r16		;recover flags
00004c bf0f      	out SREG,r16
00004d 910f      	pop r16		;recover r16
00004e 9518      	reti
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;boot handler
                 ;save unit number
                 ;read block zero
                 ;send block to host (no RSP)
                 ;set state to idle
                 ;goto idle loop
                 ;
                 st_boot:
00004f 9300 0304 	sts PK_UNIT,r16		;set unit
000051 2700      	clr r16
000052 9300 0390 	sts CUR_BL,r16		;clear block number
000054 9300 0391 	sts CUR_BH,r16
000056 2eb0      	mov FL_XOFF,r16		;clear xoff flag
000057 940e 021c 	call cf_read		;read block
000059 e0c0      	ldi r28,low(buffer)	;point to buffer
00005a e0d1      	ldi r29,high(buffer)
00005b e810      	ldi r17,128		;loop count
                 st_bo1:
00005c 9109      	ld r16,Y+		;get byte
00005d 940e 0186 	call out_chr		;send it
00005f 9109      	ld r16,Y+		;repeat
000060 940e 0186 	call out_chr
000062 9109      	ld r16,Y+
000063 940e 0186 	call out_chr
000065 9109      	ld r16,Y+
000066 940e 0186 	call out_chr
000068 951a      	dec r17
000069 f791      	brne st_bo1
                 ;
                 ;set state back to idle
00006a e730      	ldi STATEL,low(st_idle)	;idle is next
00006b e040      	ldi STATEH,high(st_idle)
00006c c05e      	rjmp idle_loop		;done
                 ;
                 ;set state to st_boot
                 boot_nxt:
00006d e43f      	ldi STATEL,low(st_boot)	;boot is next
00006e e040      	ldi STATEH,high(st_boot)
00006f cfdb      	rjmp com_rtn
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;state: idle
                 ;decode character
                 ;handle init,boot,xoff,contin
                 ;if cmd or data set buffer pointer
                 ;and next state=count
                 ;
                 st_idle:
000070 3004      	cpi r16,INITCH	;init?
000071 f0f1      	breq to_goti
000072 3008      	cpi r16,BOOTCH	;boot?
000073 f3c9      	breq boot_nxt
000074 3103      	cpi r16,XOFFCH	;xoff
000075 f419      	brne st_id01
000076 24bb      	clr FL_XOFF
000077 94b0      	com FL_XOFF
                 ;
                 ;return with same state
000078 cfd2      	rjmp com_rtn
                 ;
                 st_id01:
000079 3100      	cpi r16,CONTIN	;continue?
00007a f411      	brne st_id02
00007b 24bb      	clr FL_XOFF	;then clear flag
                 ;
                 ;return with same state
00007c cfce      	rjmp com_rtn
                 ;
                 ;must be data, cmd or error;
                 st_id02:
00007d 20aa      	tst FL_GO		;already got a packet?
00007e f469      	brne st_id04		;then error restart
00007f 9300 0300 	sts PK_FLAG,r16		;save packet type
000081 2e80      	mov CHKLO,r16		;init chksum
000082 3002      	cpi r16,CMDCH		;is packet comand?
000083 f419      	brne st_id03
000084 e0a2      	ldi r26,low(PK_OPCD)	;point to command buffer
000085 e0b3      	ldi r27,high(PK_OPCD)
000086 c006      	rjmp st_id05
                 ;
                 st_id03:
000087 3001      	cpi r16,DATACH		;is packet data?
000088 f419      	brne st_id04		;fatal error
000089 e1a0      	ldi r26,low(BF_DATA)	;point to data buffer
00008a e0b3      	ldi r27,high(BF_DATA)
00008b c001      	rjmp st_id05
                 ;
                 ;protocol error restart
                 st_id04:
00008c c108      	rjmp pro_err
                 ;
                 ;return with new state
                 st_id05:
00008d e931      	ldi STATEL,low(st_count)	;count is next
00008e e040      	ldi STATEH,high(st_count)
00008f cfbb      	rjmp com_rtn
                 ;
                 ;branch extender
                 to_goti:
000090 c021      	rjmp got_init
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;state: count
                 ;save packet count
                 ;init checksum and FL_TOG
                 ;set next state=data in
                 ;
                 st_count:
000091 9300 0301 	sts PK_CMDCT,r16	;save count character
000093 2f50      	mov COUNT,r16		;save for count down
000094 2e90      	mov CHKHI,r16		;preset checksum
000095 3801      	cpi r16,$81		;count too big?
000096 f7a8      	brcc st_id04		;
000097 24cc      	clr FL_TOG
000098 94c0      	com FL_TOG		;set toggle
000099 e93c      	ldi STATEL,low(st_data)	;data is next state
00009a e040      	ldi STATEH,high(st_data)
00009b cfaf      	rjmp com_rtn
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;state: data in
                 ;save byte
                 ;update checksum
                 ;dec count
                 ;if count=0 next state=checksum1
                 ;
                 st_data:
00009c 930d      	st X+,r16		;save data character
00009d 940e 017a 	call add2chk
00009f 955a      	dec	COUNT
0000a0 f411      	brne st_dat1		;exit in same state
0000a1 ea34      	ldi STATEL,low(st_chk1)	;checksum is next state
0000a2 e040      	ldi STATEH,high(st_chk1)
                 st_dat1:
0000a3 cfa7      	rjmp com_rtn
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;state: checksum1
                 ;if chksum error goto pro_err
                 ;next state=checksum2
                 ;
                 st_chk1:
0000a4 1508      	cp r16,CHKLO		;checksum match?
0000a5 f009      	breq st_cknx		;then check next
0000a6 c0ee      	rjmp pro_err		;else fatal error
                 st_cknx:
0000a7 ea3a      	ldi STATEL,low(st_chk2)	;checksum 2 is next state
0000a8 e040      	ldi STATEH,high(st_chk2)
0000a9 cfa1      	rjmp com_rtn
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;state: checksum2
                 ;if chksum error goto protocol error (pro_err)
                 ;next state=idle
                 ;set fl_go
                 ;
                 st_chk2:
0000aa 1509      	cp r16,CHKHI		;checksum match?
0000ab f009      	breq st_ckok		;then set go flag
0000ac c0e8      	rjmp pro_err		;else fatal error
                 st_ckok:
0000ad 24aa      	clr FL_GO
0000ae 94a0      	com FL_GO		;set go flag
0000af e730      	ldi STATEL,low(st_idle)	;set next state
0000b0 e040      	ldi STATEH,high(st_idle)
0000b1 cf99      	rjmp com_rtn
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;got init character
                 ;
                 got_init:
0000b2 e50f      	ldi r16,low(RAMEND)	;reset stack
0000b3 bf0d      	out SPL,r16
0000b4 e008      	ldi r16,high(RAMEND)
0000b5 bf0e      	out SPH,r16
0000b6 940e 010c 	call soft_init		;reset state
0000b8 940e 01a5 	call send_cont		;send continue
0000ba c010      	rjmp idle_loop		;goto idle loop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;init loop
                 ;mask off serial irq
                 ;loop: get char
                 ;if not init goto loop
                 ;reset protocol
                 ;fall through to idle loop
                 ;
                 init_loop:
0000bb 94f8      	cli			;turn off irq
0000bc e50f      	ldi r16,low(RAMEND)	;reset stack
0000bd bf0d      	out SPL,r16
0000be e008      	ldi r16,high(RAMEND)
0000bf bf0e      	out SPH,r16
                 init_lp1:
0000c0 b10b      	in r16,UCSRA		;get UART status
0000c1 ff07      	sbrs r16,RXC		;rx data rdy?
0000c2 cffd      	rjmp init_lp1		;loop if not
0000c3 955a      	dec COUNT		;too many tries?
0000c4 f409      	brne init_lp2
0000c5 c0cf      	rjmp pro_err
                 init_lp2:
0000c6 b10c      	in r16,UDR		;get char
0000c7 3004      	cpi r16,INITCH		;init?
0000c8 f7b9      	brne init_lp1		;loop if not
0000c9 940e 010c 	call soft_init		;reset protocol
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;idle loop
                 ;RSP commands return here when done
                 ; reset stack
                 ; reset flags
                 ; enable serial irq
                 ;
                 idle_loop:
                 ;
                 ;reset stack
0000cb 94f8      	cli
0000cc e50f      	ldi r16,low(RAMEND)
0000cd bf0d      	out SPL,r16
0000ce e008      	ldi r16,high(RAMEND)
0000cf bf0e      	out SPH,r16
                 ;
0000d0 2700      	clr r16
0000d1 9300 0305 	sts PK_SWIT,r16		;clear switch
0000d3 2ea0      	mov FL_GO,r16		;clear go
0000d4 9300 0394 	sts succes,r16		;clear error
0000d6 9300 0395 	sts succes+1,r16
0000d8 9300 0392 	sts byt_donl,r16	;clear count
0000da 9300 0393 	sts byt_donh,r16
0000dc 9478      	sei			;allow irq
                 ;
                 ;goto command loop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;command loop
                 ;loop till fl_go sets
                 ;if packet!=cmd goto pro_err
                 ;jump to command handler
                 ;
                 cmd_loop:
                 ;	call switches		;poll front panel
0000dd 20aa      	tst FL_GO		;valid packet recieved?
0000de f3f1      	breq cmd_loop	;loop if not
0000df 9100 0300 	lds r16,PK_FLAG
0000e1 3002      	cpi r16,CMDCH		;expecting command
0000e2 f009      	breq cmd_l01
0000e3 c0b1      	rjmp pro_err		;fatal error if not cmd
                 ;
                 cmd_l01:
0000e4 9100 0302 	lds r16,PK_OPCD		;get cmd byte
0000e6 300b      	cpi r16,$b		;in range?
0000e7 f010      	brlo cmd_l02
0000e8 ed00      	ldi r16,$d0		;error bad opcode
0000e9 c1f4      	rjmp set_succ
                 ;
                 cmd_l02:
0000ea 0f00      	lsl r16			;mult by size of entry
0000eb 710e      	andi r16,$1e	;mask off unused bits
0000ec ef14      	ldi r17,low(cmd_tbl)
0000ed 0f01      	add r16,r17		;index into table
0000ee 930f      	push r16		;push offset low
0000ef e000      	ldi r16,high(cmd_tbl)
0000f0 f408      	brcc cmd_l03
0000f1 9503      	inc r16		;carry into hi byte
                 cmd_l03:
0000f2 930f      	push r16		;push offset high
0000f3 9508      	ret			;go to routine
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;op code jump table
                 ;
                 cmd_tbl:
0000f4 940c 02ba 	jmp op_noop
0000f6 940c 02e7 	jmp op_init
0000f8 940c 02ea 	jmp op_read
0000fa 940c 0314 	jmp op_write
0000fc 940c 02ba 	jmp op_noop
0000fe 940c 033b 	jmp op_pos 
000100 940c 02ba 	jmp op_noop
000102 940c 033e 	jmp op_diag
000104 940c 033f 	jmp op_stat
000106 940c 02ba 	jmp op_noop
000108 940c 02ba 	jmp op_noop
00010a 940c 02ba 	jmp op_noop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;soft init
                 ;reset state and variables
                 ;
                 soft_init:
00010c 94f8      	cli
00010d 9100 0305 	lds r16,PK_SWIT
00010f 7008      	andi r16,0x08		;leave mrsp bit alone
000110 9300 0305 	sts PK_SWIT,r16
000112 24bb      	clr FL_XOFF
                 ;
                 ;set next state to idle
                 clr_state:
000113 e730      	ldi STATEL,low(st_idle)
000114 e040      	ldi STATEH,high(st_idle)
000115 9478      	sei
000116 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;hardware init
                 ;
                 hard_init:
                 ;
                 ;set up USART
                 ;8 bit, 1 stop, no parity
                 ;
                 ;setup port D
000117 ef1f      	ldi r17,0xff	;set bits hi
000118 bb12      	out PORTD,r17	;turn on pull ups
000119 e010      	ldi r17,0x00
00011a bb11      	out DDRD,r17	;ports to input
                 ;
                 ;select baud rate
00011b b300      	in r16,PIND		;read config
00011c 7600      	andi r16,0x60	;mask to config bits
                 ;
00011d 3000      	cpi r16,0x00	;115k
00011e f421      	brne chk38k
00011f e010      	ldi r17,0x00
000120 e005      	ldi r16,0x05
000121 940c 0131 	jmp set_br
                 ;
                 chk38k:
000123 3200      	cpi r16,0x20	;38.4k
000124 f421      	brne chk19k
000125 e010      	ldi r17,0x00
000126 e101      	ldi r16,0x11
000127 940c 0131 	jmp set_br
                 ;
                 chk19k:
000129 3400      	cpi r16,0x40	;19.2k
00012a f421      	brne set9600
00012b e010      	ldi r17,0x00
00012c e203      	ldi r16,0x23
00012d 940c 0131 	jmp set_br
                 ;
                 set9600:
00012f e010      	ldi r17,0x00	;9600
000130 e407      	ldi r16,0x47	;9600
                 ;
                 set_br:
000131 bd10      	out UBRRH,r17		;set baud rate
000132 b909      	out UBRRL,r16
                 ;
                 ;enable USART
                 ; 8 bits 1 stop no parity
000133 e908      	ldi r16,(1<<RXEN)|(1<<TXEN)|(1<<RXCIE)
000134 b90a      	out UCSRB,r16		;set uart enable
000135 e806      	ldi r16,(1<<URSEL|3<<UCSZ0)
000136 bd00      	out UCSRC,r16		;set word length
                 ;
                 ;init port B
000137 ef1f      	ldi r17,0xff		;outputs
000138 bb18      	out PORTB,r17		;set bits hi
000139 bb17      	out DDRB,r17		;set port to out
                 ;
                 ;init port C
00013a e011      	ldi r17,0x01		;bit 0 hi
00013b bb15      	out PORTC,r17
00013c e811      	ldi R17,0x81		;set direction
00013d bb14      	out DDRC,r17
                 ;
                 ;CF reset is low so kill some time
00013e 0000      	nop
00013f 0000      	nop
000140 0000      	nop
000141 0000      	nop
000142 0000      	nop
                 ;
                 ;set reset hi kill more time
000143 9aaf      	sbi PORTC,7
000144 0000      	nop
000145 0000      	nop
000146 0000      	nop
000147 0000      	nop
000148 0000      	nop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;initalize CF card
                 ;
                 CF_init:
000149 940e 015b 	call	not_bsy		;wait for CF ready
                 ;
                 ;select CF drive 0
00014b eb1e      	ldi	r17,CF_lba3	;select drive/lba
00014c ee00      	ldi	r16,CF_drv0	;lba+drive 0
00014d 940e 0161 	call put_reg		;write register
                 ;
                 ;set 8 bit mode
00014f eb19      	ldi	r17,CF_feat	;select feature
000150 e001      	ldi	r16,CF_8bit	;8 bit mode
000151 940e 0161 	call put_reg		;write register
                 ;
000153 eb1f      	ldi	r17,CF_cmd	;select cmd register
000154 ee0f      	ldi	r16,CF_sfeat	;set features
000155 940e 0161 	call put_reg		;write register
                 ;
000157 940e 015b 	call not_bsy		;read status
000159 9ac6      	sbi	PORTB,CF_csel	;deselect CF card
00015a 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;wait for CF card not busy
                 ;return status in r16
                 ;
                 not_bsy:
00015b eb1f      	ldi	r17,CF_stat	;point to status reg
                 not_by1:
00015c 940e 016d 	call	get_reg		;get status
00015e fd07      	sbrc	r16,CF_busy	;mask to busy bit
00015f cffc      	rjmp	not_by1		;loop if busy
000160 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;send byte to CF card
                 ; r16 data to send (destroyed)
                 ; r17 CF register (preserved)
                 ; output address bits (r17)
                 ; output data bits (r16)
                 ; assert write,delay,negate write
                 ;
                 put_reg:
000161 bb18      	out PORTB,r17		;select CF register
000162 bb0b      	out PORTA,r16		;set data out
000163 ef0f      	ldi r16,0xff		;port A to output
000164 bb0a      	out DDRA,r16		;set direction=out
000165 0000      	nop					;settle
                 ;
000166 98c4      	cbi PORTB,CF_wr		;assert write-
000167 0000      	nop
000168 0000      	nop
000169 0000      	nop
00016a 0000      	nop
00016b 9ac4      	sbi PORTB,CF_wr		;remove write
00016c 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;get byte from CF card
                 ; r17 CF register (preserved)
                 ; r16 returned data
                 ; output address bits (r17)
                 ; assert read,delay,negate read
                 ; input data (r16)
                 ;
                 get_reg:
00016d bb18      	out PORTB,r17		;set CF register address
00016e 0000      	nop
00016f 0000      	nop			;settle address
                 ;
                 ;set port A to input
000170 e000      	ldi r16,0x00
000171 bb0a      	out DDRA,r16	;set port direction=in
                 ;
                 ;load CF data
000172 98c3      	cbi PORTB,CF_rd		;assert read-
000173 0000      	nop
000174 0000      	nop
000175 0000      	nop
000176 0000      	nop			;access delay
000177 b309      	in r16,PINA		;read data
000178 9ac3      	sbi PORTB,CF_rd		;remove read
                 ;
000179 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;add r16 to checksum
                 ;FL_TOG is hi/low byte
                 ;flip FL_TOG
                 ;
                 add2chk:
00017a 9488      	clc
00017b 20cc      	tst FL_TOG	;test hi/low
00017c f019      	breq add_hi
                 add_lo:
00017d 1e80      	adc CHKLO,r16	;add to low
00017e f428      	brcc add_ex	;done if no carry
00017f e000      	ldi r16,0	;add 0+carry to hi
                 add_hi:
000180 1e90      	adc CHKHI,r16	;add to high
000181 f410      	brcc add_ex	;done if no carry
000182 e000      	ldi r16,0	;add 0+carry to lo
000183 cff9      	rjmp add_lo
                 add_ex:
000184 94c0      	com FL_TOG	;flip flag for next
000185 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;send character in r16 to serial port
                 ;wait for fl_xoff to clear
                 ;then send polled IO
                 ;
                 out_chr:
000186 930f      	push r16	;save character
                 outch1:
000187 20bb      	tst FL_XOFF	;wait for continue
000188 f7f1      	brne outch1
                 ;
000189 b10b      	in r16,UCSRA	;get tx status
00018a ff05      	sbrs r16,UDRE	;skip if tx empty
00018b cffb      	rjmp outch1	;loop till tx ready
00018c 910f      	pop r16		;recover character
00018d b90c      	out UDR,r16	;send it
00018e 9100 0305 	lds r16,PK_SWIT	;test for slow mode
000190 7008      	andi r16,0x08	;MRSP mode
000191 f011      	breq outch2
000192 24bb      	clr FL_XOFF
000193 94b0      	com FL_XOFF	;then set XOFF flag
                 outch2:
000194 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;protocol error
                 ;reset protocol
                 ;fall through to send init
                 ;
                 pro_err:
                 ;
                 ;reset stack
000195 94f8      	cli 
000196 e50f      	ldi r16,low(RAMEND)	;set stack
000197 bf0d      	out SPL,r16
000198 e008      	ldi r16,high(RAMEND)
000199 bf0e      	out SPH,r16
                 ;
                 ;reset state to idle
00019a e730      	ldi STATEL,low(st_idle)	;set state
00019b e040      	ldi STATEH,high(st_idle)
                 ;
                 ;reset protocol variables
00019c 940e 010c 	call soft_init
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;send init (exit via interrupt)
                 ;send init char
                 ;loop forever
                 ;
                 send_init:
00019e e004      	ldi r16,INITCH
00019f 940e 0186 	call out_chr	;send character
0001a1 e015      	ldi r17,5	;delay a bit...
0001a2 940e 01e2 	call delayl
0001a4 cff9      	rjmp  send_init	;loop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;send continue and return
                 ;
                 send_cont:
0001a5 e100      	ldi r16,CONTIN
0001a6 cfdf      	rjmp  out_chr
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;send data packet
                 ;set pointer Y to data
                 ;set packet type=data
                 ;send packet
                 ;
                 snd_data:
0001a7 e0ce      	ldi r28,low(BF_FLAG)	;point to data buffer
0001a8 e0d3      	ldi r29,high(BF_FLAG)
0001a9 e001      	ldi r16,DATACH		;set type=data
0001aa 8308      	st Y,r16
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;send packet
                 ; Y= pointer to packet header
                 ;
                 snd_rsp:
0001ab 8159      	ldd COUNT,Y+1	;get packet count
0001ac 9553      	inc COUNT	;count+2
0001ad 9553      	inc COUNT
                 ;
                 ;reset checksum state
0001ae 2488      	clr CHKLO	;clear checksum
0001af 2499      	clr CHKHI
0001b0 24cc      	clr FL_TOG
0001b1 94c0      	com FL_TOG	;preset toggle
                 ;
                 snd_r01:
0001b2 8108      	ld r16,Y	;get char
0001b3 940e 017a 	call add2chk	;add to checksum
0001b5 9109      	ld r16,Y+	;get again
0001b6 940e 0186 	call out_chr	;send it
0001b8 955a      	dec COUNT
0001b9 f7c1      	brne snd_r01	;loop till done
0001ba 2d08      	mov r16,CHKLO	;get check low
0001bb 940e 01c4 	call snd_cksum	;send it
0001bd 2d09      	mov r16,CHKHI	;get check hi
0001be 940e 01c4 	call snd_cksum
                 ;
0001c0 e500      	ldi r16,0x50	;short delay
0001c1 940e 01d7 	call delay
0001c3 9508      	ret
                 	;
                 snd_cksum:
0001c4 930f      	push r16
0001c5 e500      	ldi r16,0x50	;delay a bit...
0001c6 940e 01d7 	call delay
0001c8 910f      	pop r16
0001c9 940e 0186 	call out_chr	;send character
0001cb 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; really short delay
                 ; about 3us.
                 kil_tim:
0001cc 940e 01d0 	call kil_tim2
0001ce 940e 01d0 	call kil_tim2
                 ;
                 kil_tim2:
0001d0 0000      	nop
0001d1 0000      	nop
0001d2 0000      	nop
0001d3 0000      	nop
0001d4 0000      	nop
0001d5 0000      	nop
0001d6 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;short delay
                 ; aprox 15 us per loop
                 ; r16 = loop count
                 ;
                 delay:
0001d7 940e 01cc 	call kil_tim
0001d9 940e 01cc 	call kil_tim
0001db 940e 01cc 	call kil_tim
0001dd 940e 01cc 	call kil_tim
0001df 950a      	dec r16
0001e0 f7b1      	brne delay
0001e1 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;long delay
                 ; aprox 1.5 ms per loop
                 ;r17 = loop count
                 ;
                 delayl:
0001e2 e600      	ldi r16,$60
0001e3 940e 01d7 	call delay
0001e5 951a      	dec r17
0001e6 f7d9      	brne delayl
0001e7 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;calculate remaining bytes
                 ; carry set=last packet
                 ; R16=count for this packet
                 ;
                 ; if count >128 return cc and R16=128 
                 ; if count=128 return cs and R16=128
                 ; else (0...127) return cs and R16=remaining count
                 ;
                 remain:
0001e8 2f06      	mov r16,BYTCNTL		;save in case of underflow
0001e9 5860      	subi BYTCNTL,128	;subtract packet size
0001ea 4070      	sbci BYTCNTH,0
0001eb f028      	brcs rem_ufl		;less than 128 to go?
0001ec 2f06      	mov r16,BYTCNTL		;get low count
0001ed 2b07      	or r16,BYTCNTH		;or in hi count
0001ee e800      	ldi r16,128		;then send 128 bytes
0001ef f009      	breq rem_ufl	;exactly 128 to go?
                 ;
                 ;return with carry clear and r16=128
                 ;full size packet and more to go
0001f0 9508      	ret
                 ;
                 ;return with carry set and r16=bytes to go
                 ;packet size 1...128 and last one 
                 rem_ufl:
0001f1 9408      	sec		;set carry (last flag)
0001f2 9508      	ret			;else send BYTCNTL bytes
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;add transfer count to bytes done
                 ;r16=transfer count
                 ;
                 add_don:
0001f3 9110 0392 	lds r17,BYT_DONL
0001f5 0f10      	add r17,r16		;add transfer to bytes done
0001f6 9310 0392 	sts BYT_DONL,r17
0001f8 f428      	brcc adddon1		;carry?
0001f9 9110 0393 	lds r17,BYT_DONH
0001fb 9513      	inc r17			;inc hi byte
0001fc 9310 0393 	sts BYT_DONH,r17
                 adddon1:
0001fe 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;set starting block
                 ;reset segment number to zero
                 ;clear bytes done
                 ;set bytes to go
                 ;
                 set_blk:
0001ff 2700      	clr r16
000200 2e10      	mov BUFSEG,r16		;clear segment
000201 9300 0392 	sts BYT_DONL,r16	;clear bytes done
000203 9300 0393 	sts BYT_DONH,r16
                 ;
000205 9100 0308 	lds r16,PK_CNTL
000207 2f60      	mov BYTCNTL,r16		;set bytes to go
000208 9100 0309 	lds r16,PK_CNTH
00020a 2f70      	mov BYTCNTH,r16
                 ;
                 ;special addressing mode goes here (to do)
00020b 9100 030a 	lds r16,PK_BLKL		;set block number
00020d 9300 0390 	sts CUR_BL,r16
00020f 9100 030b 	lds r16,PK_BLKH
000211 9300 0391 	sts CUR_BH,r16
000213 9508      	ret
                 ;
                 ;test for valid unit number
000214 9100 0304 	lds r16,PK_UNIT		;get unit number
000216 7f0e      	andi r16,0xfe		;mask to 0,1
000217 f019      	breq set_bl1
000218 ef08      	ldi r16,0xf8
000219 940c 02de 	jmp set_succ		;return with error
                 ;
                 set_bl1:
00021b 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;cf card read
                 ;setup task file
                 ;issue read command
                 ;wait for drq or not busy
                 ;move data to buffer
                 ;wait for not busy
                 ;test error bit
                 ;
                 cf_read:
00021c 940e 026e 	call set_task		;set task registers
                 ;
                 ;block interrupt while doing CF io
00021e 94f8      	cli
00021f eb1f      	ldi r17,CF_cmd		;point to cmd reg
000220 e200      	ldi r16,CF_dread
000221 940e 0161 	call put_reg		;send read command
                 ;
                 ;wait for drq or not busy
                 rd_wait:
000223 eb1f      	ldi r17,CF_stat		;point to status reg
000224 940e 016d 	call get_reg		;get status
000226 fd03      	sbrc r16,CF_drq		;test DRQ bit
000227 c008      	rjmp rd_drq		;drq set?
000228 fd07      	sbrc r16,CF_busy	;test BUSY bit
000229 cff9      	rjmp rd_wait		;busy set?
                 ;
                 ;busy cleared so check error
                 rd_done:
00022a 9ac6      	sbi PORTB,CF_csel	;deselect CF card
00022b 9478      	sei			;irq ok now
00022c ff00      	sbrs r16,CF_errb	;error set?
00022d 9508      	ret
00022e ee0f      	ldi r16,$ef		;data error
00022f c0ae      	rjmp set_succ
                 ;
                 ;move data to buffer
                 ;4 bytes per loop
                 rd_drq:
000230 e850      	ldi COUNT,128		;loop counter
000231 eb18      	ldi r17,CF_data		;point to data reg
000232 e0c0      	ldi r28,low(buffer)	;point to CF buffer
000233 e0d1      	ldi r29,high(buffer)
                 ;
                 cf_rdlp:
000234 940e 016d 	call get_reg		;get byte
000236 9309      	st  Y+,r16		;save byte
000237 940e 016d 	call get_reg		;repeat
000239 9309      	st  Y+,r16
00023a 940e 016d 	call get_reg	
00023c 9309      	st  Y+,r16
00023d 940e 016d 	call get_reg	
00023f 9309      	st  Y+,r16
000240 955a      	dec COUNT
000241 f791      	brne cf_rdlp		;loop till done
000242 940e 015b 	call not_bsy		;wait for not busy
000244 cfe5      	rjmp rd_done		;check status
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;cf card write
                 ;
                 cf_write:
000245 940e 026e 	call set_task		;set task registers
                 ;
                 ;block interrupts while doing CF I/O
000247 94f8      	cli
000248 eb1f      	ldi r17,CF_cmd		;point to cmd reg
000249 e300      	ldi r16,CF_dwrite
00024a 940e 0161 	call put_reg		;issue write cmd
                 ;
                 ;wait for drq or not busy
                 wr_wait:
00024c eb1f      	ldi r17,CF_stat		;point to status reg
00024d 940e 016d 	call get_reg		;get status
00024f fd03      	sbrc r16,CF_drq
000250 c008      	rjmp wr_drq		;drq set?
000251 fd07      	sbrc r16,CF_busy
000252 cff9      	rjmp wr_wait		;loop if busy set
                 ;
                 ;error check
                 wr_eck:
000253 9ac6      	sbi PORTB,CF_csel	;deselect CF card
000254 9478      	sei			;irq ok now
000255 ff00      	sbrs r16,CF_errb	;error set?
000256 9508      	ret			;good exit
000257 ee0f      	ldi r16,$ef		;data error
000258 c085      	rjmp set_succ		;bad exit
                 ;
                 ;move data to CF card (4 bytes per loop)
                 wr_drq:
000259 e850      	ldi COUNT,128		;loop counter
00025a eb18      	ldi r17,CF_data		;point to data reg
00025b e0c0      	ldi r28,low(buffer)	;point to CF buffer
00025c e0d1      	ldi r29,high(buffer)
                 ;
                 cf_wrlp:
00025d 9109      	ld  r16,Y+		;get byte
00025e 940e 0161 	call put_reg		;put byte
000260 9109      	ld  r16,Y+		;repeat
000261 940e 0161 	call put_reg
000263 9109      	ld  r16,Y+
000264 940e 0161 	call put_reg
000266 9109      	ld  r16,Y+
000267 940e 0161 	call put_reg
000269 955a      	dec COUNT
00026a f791      	brne cf_wrlp
                 ;
                 ;wait for not busy
00026b 940e 015b 	call not_bsy
00026d cfe5      	rjmp wr_eck
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;set task file
                 ;wait for not busy
                 ;load CF  card registers
                 ;
                 set_task:
00026e 940e 015b 	call not_bsy		;wait for CF ready
                 ;
000270 eb1a      	ldi r17,CF_count	;set sector count
000271 e001      	ldi r16,1
000272 940e 0161 	call put_reg
                 ;
000274 eb1b      	ldi r17,CF_lba0		;set lba0 
000275 9100 0390 	lds r16,CUR_BL
000277 940e 0161 	call put_reg
                 ;
000279 eb1c      	ldi r17,CF_lba1		;set lba1
00027a 9100 0391 	lds r16,CUR_BH
00027c 940e 0161 	call put_reg
                 ;
00027e eb1d      	ldi r17,CF_lba2		;set lba2
00027f 9100 0304 	lds r16,PK_UNIT
000281 940e 0161 	call put_reg
                 
000283 eb1e      	ldi r17,CF_lba3		;set lba3 
000284 ee00      	ldi r16,CF_drv0
000285 940e 0161 	call put_reg
                 ;
000287 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;zero out buffer
                 ;
                 zero_buf:
000288 e0c0      	ldi r28,low(buffer)	;point to CF buffer
000289 e0d1      	ldi r29,high(buffer)
00028a e000      	ldi r16,0		;fill byte
00028b e010      	ldi r17,0		;count
                 zero_b0:
00028c 9309      	st Y+,r16		;clear a word
00028d 9309      	st Y+,r16
00028e 951a      	dec r17			;dec word count
00028f f7e1      	brne zero_b0		;loop till done
000290 9508      	ret
                 	
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;copy from buffer to packet
                 ;copy 128 bytes from CF buffer 
                 ;to packet buffer
                 ;
                 buf2pak:
000291 940e 0299 	call buf2ptr	;setup pointers
000293 e810      	ldi r17,128	;size of move
                 buf2p1:
000294 9101      	ld r16,Z+	;copy byte
000295 9309      	st Y+,r16
000296 951a      	dec r17
000297 f7e1      	brne buf2p1	;loop till done
000298 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;setup pointers for block move
                 ;Y=data packet pointer
                 ;Z=buffer pointer
                 ;
                 buf2ptr:
000299 e1c0      	ldi r28,low(bf_data)	;point to packet
00029a e0d3      	ldi r29,high(bf_data)
00029b e0e0      	ldi r30,low(buffer)	;point to CF buffer
00029c e0f1      	ldi r31,high(buffer)
00029d 2d01      	mov r16,BUFSEG		;get buffer segment
                 buf21:
00029e 2300      	tst r16
00029f f031      	breq buf22
0002a0 950a      	dec r16			;dec segment
0002a1 e810      	ldi r17,128		;add 128 to pointer
0002a2 0fe1      	add r30,r17
0002a3 f7d0      	brcc buf21		;no carry?
0002a4 95f3      	inc r31			;inc hi address
0002a5 cff8      	rjmp buf21		;and loop
                 ;
                 buf22:
0002a6 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;copy from packet to buffer
                 ;copy 128 bytes from packet buffer
                 ;to CF buffer
                 ;
                 pak2buf:
0002a7 940e 0299 	call buf2ptr	;setup pointers
0002a9 e810      	ldi r17,128	;count
                 pak2b1:
0002aa 9109      	ld r16,Y+	;move byte
0002ab 9301      	st Z+,r16
0002ac 951a      	dec r17		;dec count
0002ad f7e1      	brne pak2b1	;loop
0002ae 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;get data packet for write
                 ;
                 get_wpkt:
0002af 24aa      	clr FL_GO
0002b0 940e 01a5 	call send_cont	;prompt host for data
                 gp_wait:
0002b2 20aa      	tst fl_go
0002b3 f3f1      	breq gp_wait	;loop till go sets
0002b4 9110 0300 	lds r17,PK_FLAG
0002b6 3011      	cpi r17,DATACH	;type=data?
0002b7 f009      	breq gp_exit
0002b8 cedc      	rjmp pro_err	;fatal error
                 gp_exit:
0002b9 9508      	ret
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;command processors
                 ;
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;command: no-operation
                 ;set up response packet and send
                 ;goto idle loop
                 ;
                 op_noop:
0002ba e002      	ldi r16,$02
0002bb 9300 0300 	sts PK_FLAG,r16		;set type
                 ;
0002bd e00a      	ldi r16,$0a
0002be 9300 0301 	sts PK_CMDCT,r16	;set count
                 ;
0002c0 e400      	ldi r16,$40
0002c1 9300 0302 	sts PK_OPCD,r16		;set response code
                 ;
0002c3 9100 0394 	lds r16,SUCCES
0002c5 9300 0303 	sts PK_SUCC,r16		;set status
                 ;
0002c7 2700      	clr r16
0002c8 9300 030a 	sts PK_SUMSL,r16	;set summary status
0002ca 9100 0396 	lds r16,SUMST
0002cc 9300 030b 	sts PK_SUMSH,r16
                 ;
0002ce 9100 0392 	lds r16,byt_donl
0002d0 9300 0308 	sts PK_CNTL,r16		;set bytes done
0002d2 9100 0393 	lds r16,byt_donh
0002d4 9300 0309 	sts PK_CNTH,r16
                 ;
0002d6 e015      	ldi r17,5
0002d7 940e 01e2 	call delayl		;kill time
                 ;
0002d9 e0c0      	ldi r28,low(PK_FLAG)	;point to packet
0002da e0d3      	ldi r29,high(PK_FLAG)
0002db 940e 01ab 	call snd_rsp		;send it
0002dd cded      	rjmp idle_loop		;done
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;set success (error) code
                 ;
                 set_succ:
0002de 9300 0394 	sts SUCCES,r16		;set success code
0002e0 e800      	ldi r16,0x80
0002e1 9300 0396 	sts SUMST,r16		;set error bit
                 ;
0002e3 e50f      	ldi r16,low(RAMEND)	;reset stack
0002e4 bf0d      	out SPL,r16
0002e5 e008      	ldi r16,high(RAMEND)
0002e6 bf0e      	out SPH,r16
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;command: init
                 ;
                 op_init:
0002e7 940e 0113 	call clr_state
0002e9 cfd0      	rjmp op_noop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;command: read block(s)
                 ;
                 op_read:
0002ea 940e 01ff 	call set_blk	;set pointers
0002ec c010      	rjmp rd_lop2	;goto read loop
                 rd_lop1:
0002ed e014      	ldi r17,4
0002ee 9413      	inc BUFSEG	;point to next 
0002ef 1611      	cp BUFSEG,r17	;last segment?
0002f0 f471      	brne rd_loop	;skip increment
0002f1 2411      	clr BUFSEG	;zero segment
                 ;
0002f2 9110 0390 	lds r17,CUR_BL
0002f4 9513      	inc r17		;inc block number
0002f5 9310 0390 	sts CUR_BL,r17
                 ;
0002f7 f428      	brcc rd_lop2
                 ;
0002f8 9110 0391 	lds r17,CUR_BH
0002fa 9513      	inc r17		;inc hi byte
0002fb 9310 0391 	sts CUR_BH,r17
                 rd_lop2:
0002fd 940e 021c 	call cf_read	;read block
                 rd_loop:
0002ff 940e 0291 	call buf2pak	;move data to packet
000301 940e 01e8 	call remain	;calc remaining bytes
000303 f038      	brcs rd_fin	;lt or eq to 128 to go?
                 ;
                 ;more packets to go
000304 9300 030f 	sts BF_DATCT,r16	;set packet size
000306 940e 01f3 	call add_don	;add to bytes sent
000308 940e 01a7 	call snd_data	;send block
00030a cfe2      	rjmp rd_lop1	;loop for more
                 ;
                 ;last packet
                 rd_fin:
00030b 3000      	cpi r16,0	;zero to go?
00030c f031      	breq rd_fin1
00030d 9300 030f 	sts BF_DATCT,r16	;set packet size
00030f 940e 01f3 	call add_don	;add to bytes sent
000311 940e 01a7 	call snd_data	;send block 
                 ;
                 rd_fin1:
000313 cfa6      	rjmp op_noop	;send end packet
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;command: write block(s)
                 ;
                 op_write:
000314 940e 01ff 	call set_blk	;set starting block
000316 940e 0288 	call zero_buf	;zero data
000318 c014      	rjmp op_wri1
                 ;
                 ;inc segment,block and write to CF
                 ;if it advances to next block
                 op_wnxt:
000319 e014      	ldi r17,4
00031a 9413      	inc BUFSEG	;point to next 
00031b 1611      	cp BUFSEG,r17	;last segment?
00031c f481      	brne op_wri1	;skip writeback
00031d 940e 0245 	call cf_write	;write to CF card
00031f 940e 0288 	call zero_buf	;clear buffer
000321 2411      	clr BUFSEG	;zero segment
                 ;
000322 9110 0390 	lds r17,CUR_BL
000324 9513      	inc r17	;inc block number
000325 9310 0390 	sts CUR_BL,r17
000327 f428      	brcc op_wri1
000328 9110 0391 	lds r17,CUR_BH
00032a 9513      	inc r17		;inc block number
00032b 9310 0391 	sts CUR_BH,r17	
                 ;
                 ;ask for data
                 op_wri1:
                 ;
                 ;wait for data packet
00032d 940e 02af 	call get_wpkt	;get data from host
00032f 940e 02a7 	call pak2buf	;copy data to CF buffer
000331 9100 0301 	lds r16,PK_CMDCT
000333 940e 01f3 	call add_don	;add bytes to done
000335 940e 01e8 	call remain	;calc bytes to go
000337 f708      	brcc op_wnxt	;>128 so loop for more
                 ;
                 ;last packet in buffer so write it
                 wr_done:
000338 940e 0245 	call cf_write	;flush the buffer
00033a cf7f      	rjmp op_noop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;command: position tape 
                 ;not much to do in an emulator
                 ;set block number
                 ;goto no op
                 ;
                 op_pos:
00033b 940e 01ff 	call set_blk
00033d cf7c      	rjmp op_noop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;command: diagnostics
                 ;move along nothing to see here
                 ;goto no op 
                 ;
                 op_diag:
00033e cf7b      	rjmp op_noop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ;
                 ;command: get status
                 ;goto no op
                 ;
                 op_stat:
00033f cf7a      	rjmp op_noop
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 ;end


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32A" register use summary:
r0 :   0 r1 :   8 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   5 r9 :   5 r10:   7 r11:   8 r12:   6 r13:   0 r14:   0 r15:   0 
r16: 211 r17:  72 r18:   0 r19:  11 r20:  11 r21:  12 r22:   4 r23:   3 
r24:   0 r25:   0 r26:   2 r27:   2 r28:   7 r29:   7 r30:   2 r31:   2 
x  :   1 y  :  20 z  :   2 
Registers used: 22 out of 35 (62.9%)

"ATmega32A" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   2 add   :   3 adiw  :   0 and   :   0 
andi  :   5 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   9 brcs  :   2 break :   0 breq  :  14 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   0 brmi  :   0 
brne  :  23 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  80 cbi   :   2 cbr   :   0 
clc   :   1 clh   :   0 cli   :   8 cln   :   0 clr   :  16 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   6 cp    :   4 cpc   :   0 
cpi   :  15 cpse  :   0 dec   :  12 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   9 inc   :  11 jmp   :  39 
ld    :  12 ldd   :   1 ldi   : 124 lds   :  24 lpm   :   0 lsl   :   1 
lsr   :   0 mov   :  13 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   :  27 or    :   1 ori   :   0 out   :  29 pop   :   4 
push  :   8 rcall :   0 ret   :  27 reti  :   1 rjmp  :  47 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   1 sbi   :   6 sbic  :   0 sbis  :   0 
sbiw  :   0 sbr   :   0 sbrc  :   6 sbrs  :   4 sec   :   1 seh   :   0 
sei   :   5 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :  10 std   :   0 sts   :  34 
sub   :   0 subi  :   1 swap  :   0 tst   :   6 wdr   :   0 
Instructions used: 44 out of 113 (38.9%)

"ATmega32A" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000680   1664      0   1664   32768   5.1%
[.dseg] 0x000060 0x000398      0    664    664    2048  32.4%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
